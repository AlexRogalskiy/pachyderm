# imagePullSecret sets the image pull secret used for all images.  It
# is analogous to the --image-pull-secret argument to pachctl deploy.
imagePullSecret: "" # FIXME: should this be per-image?

dash:
  image:
    # repository is the image repo to pull from; together with tag it
    # replicates the --dash-image & --registry arguments to pachctl
    # deploy.
    repository: pachyderm/dash
    # tag is the image repo to pull from; together with repository it
    # replicates the --dash-image argument to pachctl deploy.
    tag: "0.5.57"
    pullPolicy: IfNotPresent
  # enabled controls whether the dash manifests are created or not.
  enabled: true
  # resources specifies the resource request
  resources:
    limits:
      cpu: 1
      memory: 2G
    requests:
      cpu: 1
      memory: 2G

pachd:
  image:
    repository: pachyderm/pachd
    tag: "1.12.4"
    pullPolicy: IfNotPresent
  # resources specifies the resource request
  resources:
    limits:
      cpu: 1
      memory: 2G
    requests:
      cpu: 1
      memory: 2G
  logLevel: info
  metrics:
    enabled: true
    endpoint: ""
  # noExposeDockerSocket controls whether the Docker socket is
  # exposed.  It analogous to the --no-expose-docker-socket argument
  # passed to pachctl deploy.
  noExposeDockerSocket: false
  # numShards sets the maximum number of pachd nodes allowed in the
  # cluster; increasing this number blindly can result in degraded
  # performance.  It is analogous to the --shards argument to pachctl
  # deploy.
  numShards: 16
  # blockCacheBytes sets the size of the block cache.  It is analogous
  # to the --block-cache-size argument passed to pachctl deploy.
  blockCacheBytes: "1G"
  authenticationDisabledForTesting: false
  # exposeObjectAPI controls whether the object API is exposed.  It is
  # analogous to --expose-object-api passed to pachctl deploy.
  exposeObjectAPI: false
  # clusterDeploymentID sets the Pachyderm cluster ID.
  clusterDeploymentID: ""
  # requireCriticalServersOnly only requires the critical pachd
  # servers to startup and run without errors.  It is analogous to the
  # --require-critical-servers-only argument to pachctl deploy.
  requireCriticalServersOnly: false
  ppsWorkerGRPCPort: 80
  storage:
    # uploadConcurrencyLimit sets the maximum number of concurrent
    # object storage uploads per Pachd instance.  It is analogous to
    # the --upload-concurrency-limit argument to pachctl deploy.
    uploadConcurrencyLimit: 100
    # putFileConcurrencyLimit sets the maximum number of files to
    # upload or fetch from remote sources (HTTP, blob storage) using
    # PutFile concurrently.  It is analogous to the
    # --put-file-concurrency-limit argument to pachctl deploy.
    putFileConcurrencyLimit: 100
    backend: "" # GOOGLE, AMAZON, MINIO, MICROSOFT, LOCAL
    google:
      googleBucket: ""
      googleCred: ""
      serviceAccountName: "" # For Workload Identity access to the bucket
    amazon:
      amazonRegion: ""
      amazonBucket: ""
      amazonID: ""
      amazonSecret: "" #FIXME: delete?
      amazonToken: ""  #FIXME: delete?
      amazonVaultAddr: "" #TODO Add vault to secret
      amazon-vault-role: ""
      amazon-vault-token: ""
      # cloudFrontDistribution sets the CloudFront distribution in the
      # storage secrets.  It is analogous to the
      # --cloudfront-distribution argument to pachctl deploy.
      cloudFrontDistribution: ""
      customEndpoint: ""
      retries: 10
      timeout: "5m"
      uploadACL: bucket-owner-full-control
      reverse: "true"
      partSize: 5242880
      maxUploadParts: 10000
      disableSSL: false
      logOptions: ""
      noVerifySSL: false
      iamRole: "" #TODO - ensure iam role wired up in all places
    microsoft:
      microsoftContainer: ""
      microsoftID: ""
      microsoftSecret: ""
    minio:
      minioBucket: ""
      minioEndpoint: ""
      minioID: ""
      minioSecret: ""
      minioSecure: ""
      minioSignature: ""
  service: #TODO How to handle selective ports for hub
    type: ClusterIP
    #apiGrpcPort:
    #  expose: true
    #  port: 30650
  serviceAccount:
    create: true
    name: pachyderm #TODO Set default in helpers / Wire up in templates
  workerServiceAccount:
    create: true
    # name sets the name of the worker service account.  Analogous to
    # the --worker-service-account argument to pachctl deploy.
    name: pachyderm-worker #TODO Set default in helpers / Wire up in templates

worker:
  image:
    repository: pachyderm/worker
    tag: "1.12.4"

etcd:
  image:
    repository: pachyderm/etcd
    tag: "v3.3.5"
    pullPolicy: IfNotPresent
  storageSize: "10Gi"
  # resources specifies the resource request
  resources:
    limits:
      cpu: 1
      memory: 2G
    requests:
      cpu: 1
      memory: 2G
  # storageClass indicates the etcd should use an existing
  # StorageClass for its storage.  It is analogous to the
  # --etcd-storage-class argument to pachctl deploy.
  storageClass: ""
  # dynamicNodes sets the number of nodes in the etcd StatefulSet.  It
  # is analogous to the --dynamic-etcd-nodes argument to pachctl
  # deploy.
  dynamicNodes: 1
  staticVolume: ""

imageCredentials: {}
  #registry: ""
  #username: ""
  #password: ""
  #email: ""

# move under ingress? How to make work with cert-manager, maybe add
# tls option to pachctl create secret?
tls:
  # crt is the TLS certificate, e.g. "-----BEGIN CERTIFICATE----- …"
  crt: ""
  # key is the TLS key, e.g. "-----BEGIN RSA PRIVATE KEY----- …"
  key: ""

rbac:
  # create indicates whether RBAC resources should be created.
  # Setting it to false is analogous to passing --no-rbac to pachctl
  # deploy.
  create: true
  # localRoles indicates if a Role and RoleBinding should be used
  # rather than a ClusterRole and ClusterRoleBinding; it is analogous
  # to --local-roles passed to pachctl deploy.
  localRoles: false
