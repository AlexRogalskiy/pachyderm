syntax = "proto3";

package auth;
option go_package = "github.com/pachyderm/pachyderm/src/client/auth";

import "gogoproto/gogo.proto";
import "google/protobuf/timestamp.proto";

/* A note on users
 *
 * In Pachyderm, usernames are structured strings. This makes both
 * our API and our data model more flexible (at the loss of some type safety).
 * Basically, anywhere that refers to a subject (i.e. TokenInfo) or principal 
 * (role bindings), that username will have some structured prefix.
 *
 * The current subject formats are:
 * 1) Usernames from IDPs:
 *      "IDP:MyUsername"
 * 2) Pachyderm robot users:
 *      "robot:robot_user_1"
 * 3) Pachyderm pipelines:
 *      "pipeline:terasort"
 * 4) The root token issued when auth is activated:
 *      "magic:root"
 */


/////////////////////////
//// RBAC Structures ////
/////////////////////////

// Permissions represent operations in the Pachyderm API which can be performed on resources.
// Permissions are grouped together into Roles, which are assigned to Subjects on specific resources.

// TODO: These permissions are a placeholder for the migration from ACLs to RBAC.
// Over time more granular permissions will be split out. These new, granular
// permissions can be added to the corresponding Roles so there is no change for 
// end users.
enum Permission {
  UNKNOWN_PERMISSION = 0;

  // Permissions 1-99 reserved for PFS
  REPO_ADMIN = 1;
  REPO_READ = 2;
  REPO_WRITE = 3;

  // Permissions 100-199 are cluster grants
  CLUSTER_ADMIN = 4;
}

enum ResourceType {
  UNKNOWN_RESOURCE_TYPE = 0;

  CLUSTER = 1;
  REPO = 2;
}

message Resource {
  ResourceType resourceType = 1;
  string resourceName = 2;
}

message SubjectList {
  repeated string subjects = 1; 
}

// RoleBindings represent the assignment of roles to subjects 
message RoleBindings {
  // bindings is a mapping of role -> subjects
  map<string, SubjectList> bindings = 1;
}

//// Activation API

message ActivateRequest {}

message ActivateResponse {
  // pach_token is an auth token with an indefinite lifespan for the root user
  // which can never be revoked. This should be stored securely so the cluster
  // can be administered if authentication is misconfigured. 
  string pach_token = 1;
}

message DeactivateRequest {}
message DeactivateResponse {}

// Configure Pachyderm's auth system (particularly authentication backends
message AuthConfig {
  // live_config_version identifies the version of a given pachyderm cluster's
  // current auth configuration; if a user tries to write an auth configuration
  // where live_config_version doesn't match the version of the cluster's
  // current config, the write will fail. This allows for safe
  // read+modify+write config changes.
  int64 live_config_version = 1;

  // OIDCOptions describes a OIDC-based identity provider
  message OIDCOptions {
    string issuer = 1;
    string client_id = 2 [(gogoproto.customname) = "ClientID"];
    string client_secret = 3;
    string redirect_uri = 4 [(gogoproto.customname) = "RedirectURI"];
    repeated string additional_scopes = 5;
    bool ignore_email_verified = 6;
  }

  oneof idp_configuration {
    OIDCOptions oidc = 2 [(gogoproto.customname) = "OIDC"];
  }
}

message GetConfigurationRequest {}
message GetConfigurationResponse {
  AuthConfig configuration = 1;
}
message SetConfigurationRequest {
  AuthConfig configuration = 1;
}
message SetConfigurationResponse {}

// Get the current set of principals and roles for the cluster
message GetClusterRoleBindingsRequest{}
message GetClusterRoleBindingsResponse{
  RoleBindings bindings = 1;
}

// Set cluster roles for the specified principal. Setting an empty list of roles
// revokes any roles the principal has.
message ModifyClusterRoleBindingRequest {
  string principal = 1;
  repeated string rolesToAdd = 2;
  repeated string rolesToRemove = 3;
}
message ModifyClusterRoleBindingResponse {
  
}

//// Authentication data structures

// OTPInfo is the analogue of 'TokenInfo' for Authentication Codes (short-lived,
// one-time-use codes that are passed to the frontend and then exchanged for
// longer-lived tokens)
message OTPInfo {
  // Subject (i.e. Pachyderm account) that a given OTP authenticates. This may
  // be copied into the 'subject' field of a TokenInfo, and therefore has the
  // same format, with the same prefixes.
  string subject = 1;

  // session_expiration indicates when the subject's session expires, a.k.a.
  // when the Token to which this OTP converts expires (likely later than this
  // OTP expires, but never earlier).
  google.protobuf.Timestamp session_expiration = 2;
}

// TokenInfo is the 'value' of an auth token 'key' in the 'tokens' collection
message TokenInfo {
  // Subject (i.e. Pachyderm account) that a given token authorizes. Prefixed
  // with "github:" or "robot:" to distinguish the two classes of
  // Subject in Pachyderm
  string subject = 1;

  enum TokenSource {
    INVALID = 0;
    AUTHENTICATE = 1; // returned by Authenticate()--non-revokeable
    GET_TOKEN = 2;  // returned by GetToken()--revokeable.
  }
  TokenSource source = 2;
}

//// Authentication API

message AuthenticateRequest {
  oneof credential {
    // This is a short-lived, one-time-use password generated by Pachyderm, for
    // the purpose of propagating authentication to new clients (e.g. from the
    // dash to pachd)
    string one_time_password = 1;
 
    // This is the session state that Pachyderm creates in order to keep track of
    // information related to the current OIDC session.
    string oidc_state = 2 [(gogoproto.customname) = "OIDCState"];
 
    // This is an ID Token issued by the OIDC provider.
    string id_token = 3;
  }
}

message AuthenticateResponse {
  // pach_token authenticates the caller with Pachyderm (if you want to perform
  // Pachyderm operations after auth has been activated as themselves, you must
  // present this token along with your regular request)
  string pach_token = 1;
}

message WhoAmIRequest {}

message WhoAmIResponse {
  string username = 1;
  bool is_admin = 2;
  int64 ttl = 3 [(gogoproto.customname) = "TTL"];
}

//// Authorization data structures

message Users {
  map<string, bool> usernames = 1;
}

message Groups {
  map<string, bool> groups = 1;
}

//// Authorization API

message ResourceRoleBindings {
  Resource resource = 1;
  RoleBindings bindings = 2;      
}

message AuthorizeRequest {
  // subject is the subject to authorize.
  string subject = 1;

  // bindings is the set of role bindings for the resource being requested.
  // More than one set of bindings may be supplied if the resource also inherits bindings.
  repeated ResourceRoleBindings bindings = 2;

  // permissions are the permisisons that the caller needs on the resource to
  // perform an operation.
  repeated Permission permissions = 3;
}

message AuthorizeResponse {
  // authorized is true if the caller has all the required permissions,
  // either via cluster bindings or the bindings in the request.
  bool authorized = 1;

  // missing_permissions is the set of permisisons which were requested
  // and the requester lacks
  repeated Permission missing_permissions = 2;
}

message ExplainPermissionsRequest {
  // subject is the subject to authorize.
  string subject = 1;

  // bindings is the set of role bindings for the resource being requested.
  // More than one set of bindings may be supplied if the resource also inherits bindings.
  repeated ResourceRoleBindings bindings = 2;

  // permissions are the permisisons that the caller wants explained 
  repeated Permission permissions = 3;

}

message PermissionExplanation {
  // resource is the Resource in the role binding that grants this permission
  Resource resource = 1;
   
  // role is the Role in the role binding that grants this permission
  string role = 2;

  // permisison is the Permission being granted
  Permission permission = 3;
}

message ExplainPermissionsResponse {
  // authorized is true if the caller has all the required permissions,
  // either via cluster bindings or the bindings in the request.
  bool authorized = 1;

  // missing_permissions is the set of permisisons which were requested
  // and the requester lacks
  repeated Permission missing_permissions = 2;

  // explanations are the permissions the requester has and the bindings
  // which result in those permissions being granted
  repeated PermissionExplanation permissions = 3;
}

//////////////////////////////
//// OIDC Data Structures ////
//////////////////////////////

// SessionInfo stores information associated with one OIDC authentication
// session (i.e. a single instance of a single user logging in). Sessions are
// short-lived and stored in the 'oidc-authns' collection, keyed by the OIDC
// 'state' token (30-character CSPRNG-generated string). 'GetOIDCLogin'
// generates and inserts entries, then /authorization-code/callback retrieves
// an access token from the ID provider and uses it to retrive the caller's
// email and store it in 'email', and finally Authorize() returns a Pachyderm
// token identified with that email address as a subject in Pachyderm.
message SessionInfo {
  // nonce is used by /authorization-code/callback to validate session
  // continuity with the IdP after a user has arrived there from GetOIDCLogin().
  // This is a 30-character CSPRNG-generated string.
  string nonce = 1;
  // email contains the email adddress associated with a user in their OIDC ID
  // provider. Currently users are identified with their email address rather
  // than their OIDC subject identifier to make switching between OIDC ID
  // providers easier for users, and to make user identities more easily
  // comprehensible in Pachyderm. The OIDC spec doesn't require that users'
  // emails be present or unique, but we think this will be preferable in
  // practice.
  string email = 2;
  // conversion_err indicates whether an error was encountered while exchanging
  // an auth code for an access token, or while obtaining a user's email (in
  // /authorization-code/callback). Storing the error state here allows any
  // sibling calls to Authenticate() (i.e. using the same OIDC state token) to
  // notify their caller that an error has occurred. We avoid passing the caller
  // any details of the error (which are logged by Pachyderm) to avoid giving
  // information to a user who has network access to Pachyderm but not an
  // account in the OIDC provider.
  bool conversion_err = 3;
}

//// OIDC API

message GetOIDCLoginRequest {
}

message GetOIDCLoginResponse {
  // The login URL generated for the OIDC object
  string login_url = 1 [(gogoproto.customname) = "LoginURL"];
  string state = 2;
}

//// Token API (very limited -- for pipelines)

message GetAuthTokenRequest {
  // The returned token will allow the caller to access resources as this
  // subject
  string subject = 1;

  // ttl indicates the requested (approximate) remaining lifetime of this token,
  // in seconds
  int64 ttl = 2 [(gogoproto.customname) = "TTL"];
}

message GetAuthTokenResponse {
  // A canonicalized version of the subject in the request
  string subject = 2;

  // A new auth token for the user in 'GetAuthTokenRequest.Subject' token
  string token = 1;
}

message ExtendAuthTokenRequest {
  // token indicates the Pachyderm token whose TTL is being extended
  string token = 1;

  // ttl indicates the new TTL of 'token' (if it's longer than the existing TTL)
  int64 ttl = 2 [(gogoproto.customname) = "TTL"];
}

message ExtendAuthTokenResponse {}

message RevokeAuthTokenRequest {
  string token = 1;
}

message RevokeAuthTokenResponse {}

message ModifyMembersRequest {
  string group = 1;
  repeated string add = 2;
  repeated string remove = 3;
}

message ModifyMembersResponse {}

message GetGroupsRequest {
  string username = 1;
}

message GetGroupsResponse {
  repeated string groups = 1;
}

message GetUsersRequest {
  string group = 1;
}

message GetUsersResponse {
  repeated string usernames = 1;
}

// GetOneTimePassword allows users to generate short-lived (~30s) tokens that
// can be passed to Authenticate() (via AuthenticateRequest.one_time_password)
// and exchanged for a longer-lived pachyderm token. This is more secure than
// GetAuthToken, which produces long-lived authorization tokens.
message GetOneTimePasswordRequest {
  // If the caller is an admin, GetOneTimePassword() can return a code for
  // any user (useful for testing).
  // If the caller is not an admin, GetOneTimePassword() will return an
  // authentication code for the caller if username is unset or set to the
  // caller's username (and will return an error otherwise)
  string subject = 1;

  // ttl indicates the requested (approximate) remaining lifetime of this token,
  // in seconds
  int64 ttl = 2 [(gogoproto.customname) = "TTL"];
}

message GetOneTimePasswordResponse {
  // 'code' is the string that must be presented in
  // AuthenticateRequest.one_time_password to login as
  // GetOneTimePasswordRequest.subject
  string code = 1;

  // expiration is the time at which the token in 'code' will expire
  google.protobuf.Timestamp otp_expiration = 2 [(gogoproto.customname) = "OTPExpiration"];
}

message GetRoleBindingsRequest {
  Resource resource = 1;
}

message GetRoleBindingsResponse {
  RoleBindings bindings = 1;
}

message ModifyRoleBindingsRequest {
  string subject = 1;
  Resource resource = 2;
  repeated string rolesToAdd = 3;
  repeated string rolesToRemove = 4;
}

message ModifyRoleBindingsResponse {
  // rolesDuplicated is the list of roles in rolesToAdd the subject already has
  repeated string rolesDuplicated = 1;

  // rolesAlreadyRemoved is the list of roles in rolesToRemove the subject didn't have
  repeated string rolesAlreadyRemoved = 2;
}

service API {
  // Activate/Deactivate the auth API. 'Activate' sets an initial set of admins
  // for the Pachyderm cluster, and 'Deactivate' removes all ACLs, tokens, and
  // admins from the Pachyderm cluster, making all data publicly accessable
  rpc Activate(ActivateRequest) returns (ActivateResponse) {}
  rpc Deactivate(DeactivateRequest) returns (DeactivateResponse) {}
 
  // Get/SetConfiguration manage the IDP configuration 
  rpc GetConfiguration(GetConfigurationRequest) returns (GetConfigurationResponse) {}
  rpc SetConfiguration(SetConfigurationRequest) returns (SetConfigurationResponse) {}

  // Get/ModifyClusterRoleBinding manage cluster role bindings, which are inherited by all resources in the cluster
  rpc GetRoleBindings(GetRoleBindingsRequest) returns (GetRoleBindingsResponse) {}
  rpc ModifyRoleBindings(ModifyRoleBindingsRequest) returns (ModifyRoleBindingsResponse) {}

  rpc Authenticate(AuthenticateRequest) returns (AuthenticateResponse) {}

  // Authorize is used by services to evaluate role bindings and check for the required permissions on a resource for a given subject
  rpc Authorize(AuthorizeRequest) returns (AuthorizeResponse) {}

  // ExplainPermissions shows the permissions a subject has on a resource and the bindings where they are granted
  rpc ExplainPermissions(ExplainPermissionsRequest) returns (ExplainPermissionsResponse) {}
  rpc WhoAmI(WhoAmIRequest) returns (WhoAmIResponse) {}

  rpc GetOIDCLogin(GetOIDCLoginRequest) returns (GetOIDCLoginResponse) {}

  rpc GetAuthToken(GetAuthTokenRequest) returns (GetAuthTokenResponse) {}
  rpc ExtendAuthToken(ExtendAuthTokenRequest) returns (ExtendAuthTokenResponse) {}
  rpc RevokeAuthToken(RevokeAuthTokenRequest) returns (RevokeAuthTokenResponse) {}

  rpc ModifyMembers(ModifyMembersRequest) returns (ModifyMembersResponse) {}
  rpc GetGroups(GetGroupsRequest) returns (GetGroupsResponse) {}
  rpc GetUsers(GetUsersRequest) returns (GetUsersResponse) {}

  rpc GetOneTimePassword(GetOneTimePasswordRequest) returns (GetOneTimePasswordResponse) {}
}
