// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: internal/metrics/metrics.proto

package metrics

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Metrics struct {
	ClusterID            string   `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	PodID                string   `protobuf:"bytes,2,opt,name=pod_id,json=podId,proto3" json:"pod_id,omitempty"`
	Nodes                int64    `protobuf:"varint,3,opt,name=nodes,proto3" json:"nodes,omitempty"`
	Version              string   `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	Repos                int64    `protobuf:"varint,5,opt,name=repos,proto3" json:"repos,omitempty"`
	Commits              int64    `protobuf:"varint,6,opt,name=commits,proto3" json:"commits,omitempty"`
	Files                int64    `protobuf:"varint,7,opt,name=files,proto3" json:"files,omitempty"`
	Bytes                uint64   `protobuf:"varint,8,opt,name=bytes,proto3" json:"bytes,omitempty"`
	Jobs                 int64    `protobuf:"varint,9,opt,name=jobs,proto3" json:"jobs,omitempty"`
	Pipelines            int64    `protobuf:"varint,10,opt,name=pipelines,proto3" json:"pipelines,omitempty"`
	ArchivedCommits      int64    `protobuf:"varint,11,opt,name=archived_commits,json=archivedCommits,proto3" json:"archived_commits,omitempty"`
	CancelledCommits     int64    `protobuf:"varint,12,opt,name=cancelled_commits,json=cancelledCommits,proto3" json:"cancelled_commits,omitempty"`
	ActivationCode       string   `protobuf:"bytes,13,opt,name=activation_code,json=activationCode,proto3" json:"activation_code,omitempty"`
	MaxBranches          uint64   `protobuf:"varint,14,opt,name=max_branches,json=maxBranches,proto3" json:"max_branches,omitempty"`
	PpsSpout             bool     `protobuf:"varint,15,opt,name=pps_spout,json=ppsSpout,proto3" json:"pps_spout,omitempty"`
	PpsSpoutService      bool     `protobuf:"varint,16,opt,name=pps_spout_service,json=ppsSpoutService,proto3" json:"pps_spout_service,omitempty"`
	PpsBuild             bool     `protobuf:"varint,17,opt,name=pps_build,json=ppsBuild,proto3" json:"pps_build,omitempty"`
	CfgEgress            bool     `protobuf:"varint,18,opt,name=cfg_egress,json=cfgEgress,proto3" json:"cfg_egress,omitempty"`
	CfgStandby           bool     `protobuf:"varint,19,opt,name=cfg_standby,json=cfgStandby,proto3" json:"cfg_standby,omitempty"`
	CfgS3Gateway         bool     `protobuf:"varint,20,opt,name=cfg_s3gateway,json=cfgS3gateway,proto3" json:"cfg_s3gateway,omitempty"`
	CfgServices          bool     `protobuf:"varint,21,opt,name=cfg_services,json=cfgServices,proto3" json:"cfg_services,omitempty"`
	CfgErrcmd            bool     `protobuf:"varint,22,opt,name=cfg_errcmd,json=cfgErrcmd,proto3" json:"cfg_errcmd,omitempty"`
	CfgStats             bool     `protobuf:"varint,23,opt,name=cfg_stats,json=cfgStats,proto3" json:"cfg_stats,omitempty"`
	CfgTfjob             bool     `protobuf:"varint,24,opt,name=cfg_tfjob,json=cfgTfjob,proto3" json:"cfg_tfjob,omitempty"`
	InputGroup           bool     `protobuf:"varint,25,opt,name=input_group,json=inputGroup,proto3" json:"input_group,omitempty"`
	InputJoin            bool     `protobuf:"varint,26,opt,name=input_join,json=inputJoin,proto3" json:"input_join,omitempty"`
	InputCross           bool     `protobuf:"varint,27,opt,name=input_cross,json=inputCross,proto3" json:"input_cross,omitempty"`
	InputUnion           bool     `protobuf:"varint,28,opt,name=input_union,json=inputUnion,proto3" json:"input_union,omitempty"`
	InputCron            bool     `protobuf:"varint,29,opt,name=input_cron,json=inputCron,proto3" json:"input_cron,omitempty"`
	InputGit             bool     `protobuf:"varint,30,opt,name=input_git,json=inputGit,proto3" json:"input_git,omitempty"`
	InputOuterJoin       bool     `protobuf:"varint,31,opt,name=input_outer_join,json=inputOuterJoin,proto3" json:"input_outer_join,omitempty"`
	InputLazy            bool     `protobuf:"varint,32,opt,name=input_lazy,json=inputLazy,proto3" json:"input_lazy,omitempty"`
	InputEmptyFiles      bool     `protobuf:"varint,33,opt,name=input_empty_files,json=inputEmptyFiles,proto3" json:"input_empty_files,omitempty"`
	InputS3              bool     `protobuf:"varint,34,opt,name=input_s3,json=inputS3,proto3" json:"input_s3,omitempty"`
	InputTrigger         bool     `protobuf:"varint,35,opt,name=input_trigger,json=inputTrigger,proto3" json:"input_trigger,omitempty"`
	ResourceCpu          bool     `protobuf:"varint,36,opt,name=resource_cpu,json=resourceCpu,proto3" json:"resource_cpu,omitempty"`
	ResourceMem          bool     `protobuf:"varint,37,opt,name=resource_mem,json=resourceMem,proto3" json:"resource_mem,omitempty"`
	ResourceGpu          bool     `protobuf:"varint,38,opt,name=resource_gpu,json=resourceGpu,proto3" json:"resource_gpu,omitempty"`
	ResourceDisk         bool     `protobuf:"varint,39,opt,name=resource_disk,json=resourceDisk,proto3" json:"resource_disk,omitempty"`
	MaxParallelism       uint64   `protobuf:"varint,40,opt,name=max_parallelism,json=maxParallelism,proto3" json:"max_parallelism,omitempty"`
	MinParallelism       uint64   `protobuf:"varint,41,opt,name=min_parallelism,json=minParallelism,proto3" json:"min_parallelism,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Metrics) Reset()         { *m = Metrics{} }
func (m *Metrics) String() string { return proto.CompactTextString(m) }
func (*Metrics) ProtoMessage()    {}
func (*Metrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_80696bde8ca4d1c7, []int{0}
}
func (m *Metrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metrics.Merge(m, src)
}
func (m *Metrics) XXX_Size() int {
	return m.Size()
}
func (m *Metrics) XXX_DiscardUnknown() {
	xxx_messageInfo_Metrics.DiscardUnknown(m)
}

var xxx_messageInfo_Metrics proto.InternalMessageInfo

func (m *Metrics) GetClusterID() string {
	if m != nil {
		return m.ClusterID
	}
	return ""
}

func (m *Metrics) GetPodID() string {
	if m != nil {
		return m.PodID
	}
	return ""
}

func (m *Metrics) GetNodes() int64 {
	if m != nil {
		return m.Nodes
	}
	return 0
}

func (m *Metrics) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Metrics) GetRepos() int64 {
	if m != nil {
		return m.Repos
	}
	return 0
}

func (m *Metrics) GetCommits() int64 {
	if m != nil {
		return m.Commits
	}
	return 0
}

func (m *Metrics) GetFiles() int64 {
	if m != nil {
		return m.Files
	}
	return 0
}

func (m *Metrics) GetBytes() uint64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

func (m *Metrics) GetJobs() int64 {
	if m != nil {
		return m.Jobs
	}
	return 0
}

func (m *Metrics) GetPipelines() int64 {
	if m != nil {
		return m.Pipelines
	}
	return 0
}

func (m *Metrics) GetArchivedCommits() int64 {
	if m != nil {
		return m.ArchivedCommits
	}
	return 0
}

func (m *Metrics) GetCancelledCommits() int64 {
	if m != nil {
		return m.CancelledCommits
	}
	return 0
}

func (m *Metrics) GetActivationCode() string {
	if m != nil {
		return m.ActivationCode
	}
	return ""
}

func (m *Metrics) GetMaxBranches() uint64 {
	if m != nil {
		return m.MaxBranches
	}
	return 0
}

func (m *Metrics) GetPpsSpout() bool {
	if m != nil {
		return m.PpsSpout
	}
	return false
}

func (m *Metrics) GetPpsSpoutService() bool {
	if m != nil {
		return m.PpsSpoutService
	}
	return false
}

func (m *Metrics) GetPpsBuild() bool {
	if m != nil {
		return m.PpsBuild
	}
	return false
}

func (m *Metrics) GetCfgEgress() bool {
	if m != nil {
		return m.CfgEgress
	}
	return false
}

func (m *Metrics) GetCfgStandby() bool {
	if m != nil {
		return m.CfgStandby
	}
	return false
}

func (m *Metrics) GetCfgS3Gateway() bool {
	if m != nil {
		return m.CfgS3Gateway
	}
	return false
}

func (m *Metrics) GetCfgServices() bool {
	if m != nil {
		return m.CfgServices
	}
	return false
}

func (m *Metrics) GetCfgErrcmd() bool {
	if m != nil {
		return m.CfgErrcmd
	}
	return false
}

func (m *Metrics) GetCfgStats() bool {
	if m != nil {
		return m.CfgStats
	}
	return false
}

func (m *Metrics) GetCfgTfjob() bool {
	if m != nil {
		return m.CfgTfjob
	}
	return false
}

func (m *Metrics) GetInputGroup() bool {
	if m != nil {
		return m.InputGroup
	}
	return false
}

func (m *Metrics) GetInputJoin() bool {
	if m != nil {
		return m.InputJoin
	}
	return false
}

func (m *Metrics) GetInputCross() bool {
	if m != nil {
		return m.InputCross
	}
	return false
}

func (m *Metrics) GetInputUnion() bool {
	if m != nil {
		return m.InputUnion
	}
	return false
}

func (m *Metrics) GetInputCron() bool {
	if m != nil {
		return m.InputCron
	}
	return false
}

func (m *Metrics) GetInputGit() bool {
	if m != nil {
		return m.InputGit
	}
	return false
}

func (m *Metrics) GetInputOuterJoin() bool {
	if m != nil {
		return m.InputOuterJoin
	}
	return false
}

func (m *Metrics) GetInputLazy() bool {
	if m != nil {
		return m.InputLazy
	}
	return false
}

func (m *Metrics) GetInputEmptyFiles() bool {
	if m != nil {
		return m.InputEmptyFiles
	}
	return false
}

func (m *Metrics) GetInputS3() bool {
	if m != nil {
		return m.InputS3
	}
	return false
}

func (m *Metrics) GetInputTrigger() bool {
	if m != nil {
		return m.InputTrigger
	}
	return false
}

func (m *Metrics) GetResourceCpu() bool {
	if m != nil {
		return m.ResourceCpu
	}
	return false
}

func (m *Metrics) GetResourceMem() bool {
	if m != nil {
		return m.ResourceMem
	}
	return false
}

func (m *Metrics) GetResourceGpu() bool {
	if m != nil {
		return m.ResourceGpu
	}
	return false
}

func (m *Metrics) GetResourceDisk() bool {
	if m != nil {
		return m.ResourceDisk
	}
	return false
}

func (m *Metrics) GetMaxParallelism() uint64 {
	if m != nil {
		return m.MaxParallelism
	}
	return 0
}

func (m *Metrics) GetMinParallelism() uint64 {
	if m != nil {
		return m.MinParallelism
	}
	return 0
}

func init() {
	proto.RegisterType((*Metrics)(nil), "metrics.Metrics")
}

func init() { proto.RegisterFile("internal/metrics/metrics.proto", fileDescriptor_80696bde8ca4d1c7) }

var fileDescriptor_80696bde8ca4d1c7 = []byte{
	// 786 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x94, 0xcb, 0x6e, 0x1b, 0x37,
	0x14, 0x86, 0xa1, 0xc6, 0xb6, 0x2c, 0xfa, 0xce, 0xba, 0xed, 0xc9, 0x4d, 0x56, 0x92, 0xb6, 0x51,
	0xda, 0x22, 0x02, 0x6a, 0xa0, 0x0f, 0x60, 0x39, 0x0d, 0x5c, 0x34, 0x68, 0x20, 0xa7, 0x9b, 0x6e,
	0x06, 0x14, 0x87, 0x1e, 0xd1, 0x99, 0x21, 0x09, 0x92, 0xa3, 0x5a, 0x79, 0xc2, 0x2e, 0xbb, 0xe9,
	0xd6, 0x28, 0xf4, 0x24, 0xc5, 0x39, 0xd4, 0xe8, 0xd2, 0x95, 0xe6, 0x7c, 0xe7, 0xe3, 0xf0, 0xa7,
	0x48, 0x0e, 0xeb, 0x6a, 0x13, 0x95, 0x37, 0xa2, 0x1c, 0x54, 0x2a, 0x7a, 0x2d, 0x43, 0xf3, 0xfb,
	0xda, 0x79, 0x1b, 0x2d, 0x6f, 0x2f, 0xca, 0x47, 0xa7, 0x85, 0x2d, 0x2c, 0xb1, 0x01, 0x3e, 0xa5,
	0xf6, 0xf3, 0x7f, 0x18, 0x6b, 0xbf, 0x4b, 0x06, 0xff, 0x81, 0x31, 0x59, 0xd6, 0x21, 0x2a, 0x9f,
	0xe9, 0x1c, 0x5a, 0xbd, 0x56, 0xbf, 0x73, 0x71, 0x30, 0xbf, 0x3f, 0xeb, 0x0c, 0x13, 0xbd, 0xba,
	0x1c, 0x75, 0x16, 0xc2, 0x55, 0xce, 0x7b, 0x6c, 0xc7, 0xd9, 0x1c, 0xcd, 0xcf, 0xc8, 0xec, 0xcc,
	0xef, 0xcf, 0xb6, 0xdf, 0xdb, 0xfc, 0xea, 0x72, 0xb4, 0xed, 0x6c, 0x7e, 0x95, 0xf3, 0x53, 0xb6,
	0x6d, 0x6c, 0xae, 0x02, 0x3c, 0xe8, 0xb5, 0xfa, 0x0f, 0x46, 0xa9, 0xe0, 0xc0, 0xda, 0x53, 0xe5,
	0x83, 0xb6, 0x06, 0xb6, 0x70, 0xe0, 0xa8, 0x29, 0xd1, 0xf7, 0xca, 0xd9, 0x00, 0xdb, 0xc9, 0xa7,
	0x02, 0x7d, 0x69, 0xab, 0x4a, 0xc7, 0x00, 0x3b, 0xc4, 0x9b, 0x12, 0xfd, 0x1b, 0x5d, 0xaa, 0x00,
	0xed, 0xe4, 0x53, 0x81, 0x74, 0x3c, 0x8b, 0x2a, 0xc0, 0x6e, 0xaf, 0xd5, 0xdf, 0x1a, 0xa5, 0x82,
	0x73, 0xb6, 0x75, 0x6b, 0xc7, 0x01, 0x3a, 0xa4, 0xd2, 0x33, 0x7f, 0xc2, 0x3a, 0x4e, 0x3b, 0x55,
	0x6a, 0xa3, 0x02, 0x30, 0x6a, 0xac, 0x00, 0x7f, 0xc5, 0x8e, 0x85, 0x97, 0x13, 0x3d, 0x55, 0x79,
	0xd6, 0x04, 0xd8, 0x23, 0xe9, 0xa8, 0xe1, 0xc3, 0x45, 0x90, 0xef, 0xd9, 0x89, 0x14, 0x46, 0xaa,
	0xb2, 0x5c, 0x73, 0xf7, 0xc9, 0x3d, 0x5e, 0x36, 0x1a, 0xf9, 0x25, 0x3b, 0x12, 0x32, 0xea, 0xa9,
	0x88, 0xda, 0x9a, 0x4c, 0xda, 0x5c, 0xc1, 0x01, 0xfd, 0x0f, 0x87, 0x2b, 0x3c, 0xb4, 0xb9, 0xe2,
	0xcf, 0xd8, 0x7e, 0x25, 0xee, 0xb2, 0xb1, 0x17, 0x46, 0x4e, 0x54, 0x80, 0x43, 0x5a, 0xcf, 0x5e,
	0x25, 0xee, 0x2e, 0x16, 0x88, 0x3f, 0x66, 0x1d, 0xe7, 0x42, 0x16, 0x9c, 0xad, 0x23, 0x1c, 0xf5,
	0x5a, 0xfd, 0xdd, 0xd1, 0xae, 0x73, 0xe1, 0x1a, 0x6b, 0xfe, 0x1d, 0x3b, 0x59, 0x36, 0xb3, 0xa0,
	0xfc, 0x54, 0x4b, 0x05, 0xc7, 0x24, 0x1d, 0x35, 0xd2, 0x75, 0xc2, 0xcd, 0x8b, 0xc6, 0xb5, 0x2e,
	0x73, 0x38, 0x59, 0xbe, 0xe8, 0x02, 0x6b, 0xfe, 0x94, 0x31, 0x79, 0x53, 0x64, 0xaa, 0xf0, 0x2a,
	0x04, 0xe0, 0xd4, 0xed, 0xc8, 0x9b, 0xe2, 0x0d, 0x01, 0x7e, 0xc6, 0xf6, 0xb0, 0x1d, 0xa2, 0x30,
	0xf9, 0x78, 0x06, 0x9f, 0x53, 0x1f, 0x47, 0x5c, 0x27, 0xc2, 0x5f, 0xb0, 0x03, 0x12, 0xce, 0x0b,
	0x11, 0xd5, 0x9f, 0x62, 0x06, 0xa7, 0xa4, 0xec, 0xa3, 0xd2, 0x30, 0x5c, 0x2d, 0x49, 0x29, 0x50,
	0x80, 0x2f, 0xc8, 0xc1, 0x37, 0x2f, 0x32, 0x86, 0x65, 0x0e, 0xef, 0x65, 0x95, 0xc3, 0x97, 0xab,
	0x1c, 0x04, 0x70, 0x0d, 0x8b, 0x1c, 0x31, 0xc0, 0x57, 0x69, 0x0d, 0x29, 0x45, 0x0c, 0x4d, 0x33,
	0xde, 0xdc, 0xda, 0x31, 0xc0, 0xb2, 0xf9, 0x01, 0x6b, 0x5c, 0x81, 0x36, 0xae, 0x8e, 0x59, 0xe1,
	0x6d, 0xed, 0xe0, 0x61, 0x5a, 0x01, 0xa1, 0xb7, 0x48, 0x70, 0xe6, 0x24, 0xdc, 0x5a, 0x6d, 0xe0,
	0x51, 0x9a, 0x99, 0xc8, 0x2f, 0x56, 0x9b, 0xd5, 0x78, 0xe9, 0x6d, 0x08, 0xf0, 0x78, 0x6d, 0xfc,
	0x10, 0xc9, 0x4a, 0xa8, 0x0d, 0x9e, 0xfb, 0x27, 0x6b, 0xc2, 0xef, 0x48, 0x56, 0x13, 0x48, 0x6f,
	0x0d, 0x3c, 0x5d, 0x9b, 0x60, 0xe8, 0xad, 0xc1, 0xf4, 0x8b, 0x80, 0x3a, 0x42, 0x37, 0xa5, 0x4f,
	0xf1, 0x74, 0xe4, 0x7d, 0x76, 0x9c, 0x9a, 0xb6, 0xc6, 0xab, 0x4b, 0x11, 0xcf, 0xc8, 0x39, 0x24,
	0xfe, 0x1b, 0x62, 0xca, 0xb9, 0x9c, 0xa5, 0x14, 0x9f, 0x66, 0xd0, 0x5b, 0x9b, 0xe5, 0x57, 0xf1,
	0x69, 0x86, 0x07, 0x26, 0xb5, 0x55, 0xe5, 0xe2, 0x2c, 0x4b, 0x77, 0xeb, 0x59, 0x3a, 0x30, 0xd4,
	0x78, 0x83, 0xfc, 0x67, 0xba, 0x65, 0x0f, 0x59, 0x0a, 0x90, 0x85, 0x73, 0x78, 0x4e, 0x4a, 0x9b,
	0xea, 0xeb, 0x73, 0xdc, 0xee, 0xd4, 0x8a, 0x5e, 0x17, 0x85, 0xf2, 0xf0, 0x22, 0x6d, 0x37, 0xc1,
	0x0f, 0x89, 0xe1, 0x76, 0x7b, 0x15, 0x6c, 0xed, 0xa5, 0xca, 0xa4, 0xab, 0xe1, 0xeb, 0xb4, 0xdd,
	0x0d, 0x1b, 0xba, 0x7a, 0x43, 0xa9, 0x54, 0x05, 0xdf, 0x6c, 0x2a, 0xef, 0x54, 0xb5, 0xa1, 0x14,
	0xae, 0x86, 0x6f, 0x37, 0x95, 0xb7, 0xae, 0xc6, 0x34, 0x4b, 0x25, 0xd7, 0xe1, 0x23, 0xbc, 0x4c,
	0x69, 0x1a, 0x78, 0xa9, 0xc3, 0x47, 0xbc, 0x93, 0x78, 0xd5, 0x9c, 0xf0, 0xa2, 0x2c, 0x55, 0xa9,
	0x43, 0x05, 0x7d, 0xba, 0x6d, 0x87, 0x95, 0xb8, 0x7b, 0xbf, 0xa2, 0x24, 0x6a, 0xb3, 0x21, 0xbe,
	0x5a, 0x88, 0xda, 0xac, 0x89, 0x17, 0x97, 0x7f, 0xcd, 0xbb, 0xad, 0xbf, 0xe7, 0xdd, 0xd6, 0xbf,
	0xf3, 0x6e, 0xeb, 0x8f, 0x9f, 0x0a, 0x1d, 0x27, 0xf5, 0xf8, 0xb5, 0xb4, 0xd5, 0xc0, 0x09, 0x39,
	0x99, 0xe5, 0xca, 0xaf, 0x3f, 0x4d, 0x7f, 0x1c, 0x04, 0x2f, 0x07, 0xff, 0xff, 0x94, 0x8f, 0x77,
	0xe8, 0x23, 0x7d, 0xfe, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5e, 0x23, 0x69, 0x03, 0xe5, 0x05,
	0x00, 0x00,
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MinParallelism != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.MinParallelism))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.MaxParallelism != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.MaxParallelism))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.ResourceDisk {
		i--
		if m.ResourceDisk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.ResourceGpu {
		i--
		if m.ResourceGpu {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.ResourceMem {
		i--
		if m.ResourceMem {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.ResourceCpu {
		i--
		if m.ResourceCpu {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.InputTrigger {
		i--
		if m.InputTrigger {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.InputS3 {
		i--
		if m.InputS3 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.InputEmptyFiles {
		i--
		if m.InputEmptyFiles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.InputLazy {
		i--
		if m.InputLazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.InputOuterJoin {
		i--
		if m.InputOuterJoin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.InputGit {
		i--
		if m.InputGit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.InputCron {
		i--
		if m.InputCron {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.InputUnion {
		i--
		if m.InputUnion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.InputCross {
		i--
		if m.InputCross {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.InputJoin {
		i--
		if m.InputJoin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.InputGroup {
		i--
		if m.InputGroup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.CfgTfjob {
		i--
		if m.CfgTfjob {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.CfgStats {
		i--
		if m.CfgStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.CfgErrcmd {
		i--
		if m.CfgErrcmd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.CfgServices {
		i--
		if m.CfgServices {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CfgS3Gateway {
		i--
		if m.CfgS3Gateway {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.CfgStandby {
		i--
		if m.CfgStandby {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.CfgEgress {
		i--
		if m.CfgEgress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.PpsBuild {
		i--
		if m.PpsBuild {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.PpsSpoutService {
		i--
		if m.PpsSpoutService {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.PpsSpout {
		i--
		if m.PpsSpout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.MaxBranches != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.MaxBranches))
		i--
		dAtA[i] = 0x70
	}
	if len(m.ActivationCode) > 0 {
		i -= len(m.ActivationCode)
		copy(dAtA[i:], m.ActivationCode)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.ActivationCode)))
		i--
		dAtA[i] = 0x6a
	}
	if m.CancelledCommits != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.CancelledCommits))
		i--
		dAtA[i] = 0x60
	}
	if m.ArchivedCommits != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.ArchivedCommits))
		i--
		dAtA[i] = 0x58
	}
	if m.Pipelines != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Pipelines))
		i--
		dAtA[i] = 0x50
	}
	if m.Jobs != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Jobs))
		i--
		dAtA[i] = 0x48
	}
	if m.Bytes != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Bytes))
		i--
		dAtA[i] = 0x40
	}
	if m.Files != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Files))
		i--
		dAtA[i] = 0x38
	}
	if m.Commits != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Commits))
		i--
		dAtA[i] = 0x30
	}
	if m.Repos != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Repos))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x22
	}
	if m.Nodes != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Nodes))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PodID) > 0 {
		i -= len(m.PodID)
		copy(dAtA[i:], m.PodID)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.PodID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterID) > 0 {
		i -= len(m.ClusterID)
		copy(dAtA[i:], m.ClusterID)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.ClusterID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMetrics(dAtA []byte, offset int, v uint64) int {
	offset -= sovMetrics(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = len(m.PodID)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.Nodes != 0 {
		n += 1 + sovMetrics(uint64(m.Nodes))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.Repos != 0 {
		n += 1 + sovMetrics(uint64(m.Repos))
	}
	if m.Commits != 0 {
		n += 1 + sovMetrics(uint64(m.Commits))
	}
	if m.Files != 0 {
		n += 1 + sovMetrics(uint64(m.Files))
	}
	if m.Bytes != 0 {
		n += 1 + sovMetrics(uint64(m.Bytes))
	}
	if m.Jobs != 0 {
		n += 1 + sovMetrics(uint64(m.Jobs))
	}
	if m.Pipelines != 0 {
		n += 1 + sovMetrics(uint64(m.Pipelines))
	}
	if m.ArchivedCommits != 0 {
		n += 1 + sovMetrics(uint64(m.ArchivedCommits))
	}
	if m.CancelledCommits != 0 {
		n += 1 + sovMetrics(uint64(m.CancelledCommits))
	}
	l = len(m.ActivationCode)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.MaxBranches != 0 {
		n += 1 + sovMetrics(uint64(m.MaxBranches))
	}
	if m.PpsSpout {
		n += 2
	}
	if m.PpsSpoutService {
		n += 3
	}
	if m.PpsBuild {
		n += 3
	}
	if m.CfgEgress {
		n += 3
	}
	if m.CfgStandby {
		n += 3
	}
	if m.CfgS3Gateway {
		n += 3
	}
	if m.CfgServices {
		n += 3
	}
	if m.CfgErrcmd {
		n += 3
	}
	if m.CfgStats {
		n += 3
	}
	if m.CfgTfjob {
		n += 3
	}
	if m.InputGroup {
		n += 3
	}
	if m.InputJoin {
		n += 3
	}
	if m.InputCross {
		n += 3
	}
	if m.InputUnion {
		n += 3
	}
	if m.InputCron {
		n += 3
	}
	if m.InputGit {
		n += 3
	}
	if m.InputOuterJoin {
		n += 3
	}
	if m.InputLazy {
		n += 3
	}
	if m.InputEmptyFiles {
		n += 3
	}
	if m.InputS3 {
		n += 3
	}
	if m.InputTrigger {
		n += 3
	}
	if m.ResourceCpu {
		n += 3
	}
	if m.ResourceMem {
		n += 3
	}
	if m.ResourceGpu {
		n += 3
	}
	if m.ResourceDisk {
		n += 3
	}
	if m.MaxParallelism != 0 {
		n += 2 + sovMetrics(uint64(m.MaxParallelism))
	}
	if m.MinParallelism != 0 {
		n += 2 + sovMetrics(uint64(m.MinParallelism))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMetrics(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetrics(x uint64) (n int) {
	return sovMetrics(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			m.Nodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nodes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repos", wireType)
			}
			m.Repos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Repos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			m.Commits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			m.Files = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Files |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobs", wireType)
			}
			m.Jobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Jobs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipelines", wireType)
			}
			m.Pipelines = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pipelines |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchivedCommits", wireType)
			}
			m.ArchivedCommits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArchivedCommits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelledCommits", wireType)
			}
			m.CancelledCommits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CancelledCommits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivationCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBranches", wireType)
			}
			m.MaxBranches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBranches |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PpsSpout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PpsSpout = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PpsSpoutService", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PpsSpoutService = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PpsBuild", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PpsBuild = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgEgress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CfgEgress = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgStandby", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CfgStandby = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgS3Gateway", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CfgS3Gateway = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgServices", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CfgServices = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgErrcmd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CfgErrcmd = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CfgStats = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgTfjob", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CfgTfjob = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputGroup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InputGroup = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputJoin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InputJoin = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputCross", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InputCross = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputUnion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InputUnion = bool(v != 0)
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputCron", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InputCron = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputGit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InputGit = bool(v != 0)
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputOuterJoin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InputOuterJoin = bool(v != 0)
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputLazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InputLazy = bool(v != 0)
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputEmptyFiles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InputEmptyFiles = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputS3", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InputS3 = bool(v != 0)
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputTrigger", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InputTrigger = bool(v != 0)
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceCpu", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResourceCpu = bool(v != 0)
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceMem", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResourceMem = bool(v != 0)
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGpu", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResourceGpu = bool(v != 0)
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceDisk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResourceDisk = bool(v != 0)
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxParallelism", wireType)
			}
			m.MaxParallelism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxParallelism |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinParallelism", wireType)
			}
			m.MinParallelism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinParallelism |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetrics(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetrics
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMetrics
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMetrics
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMetrics        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetrics          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMetrics = fmt.Errorf("proto: unexpected end of group")
)
